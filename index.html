<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>MAJ COXX ‚Äì Import besoins (ZIP) ‚Üí Profil hebdo</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:24px;max-width:980px}
  h1{margin:0 0 12px 0;font-size:22px}
  .row{display:flex;gap:16px;flex-wrap:wrap;margin:12px 0}
  .card{border:1px solid #ddd;border-radius:12px;padding:14px;flex:1;min-width:280px}
  label{display:block;font-weight:600;margin-bottom:6px}
  input,select,button{font-size:14px}
  input[type=file]{width:100%}
  button{padding:10px 14px;border-radius:10px;border:1px solid #222;background:#111;color:#fff;cursor:pointer}
  button:disabled{opacity:.5;cursor:not-allowed}
  .muted{color:#666;font-size:13px}
  .ok{color:#0a7a2f}
  .err{color:#b00020}
  pre{background:#0b0b0b;color:#eaeaea;padding:12px;border-radius:12px;overflow:auto;max-height:340px}
  .pill{display:inline-block;padding:3px 8px;border-radius:999px;background:#f3f3f3;margin-left:8px;font-size:12px}
</style>
</head>
<body>
  <h1>MAJ ‚Äì Besoins COXX (litres) ‚Üí Profil hebdo (unit√©s/semaine)</h1>
  <p class="muted">Charge ton <b>HTML stock</b> puis un <b>ZIP</b> contenant <code>BESOINS 01 JANVIER.csv</code>‚Ä¶<code>BESOINS 12 DECEMBRE.csv</code> + <code>BESOINS ANNEE.csv</code>. L‚Äôoutil met √† jour uniquement <b>Soft</b> et <b>Alcool</b>.</p>

  <div class="row">
    <div class="card">
      <label>1) HTML de base (outil stock)</label>
      <input id="baseHtml" type="file" accept=".html,text/html"/>
      <div id="baseHtmlStatus" class="muted">Aucun fichier charg√©</div>
    </div>

    <div class="card">
      <label>2) ZIP Besoins (12 mois + ann√©e)</label>
      <input id="zipNeeds" type="file" accept=".zip,application/zip"/>
      <div id="zipStatus" class="muted">Aucun fichier charg√©</div>
    </div>

    <div class="card">
      <label>Ann√©e de projection (ISO)</label>
      <select id="yearSel">
        <option value="2026" selected>2026 (53 semaines)</option>
        <option value="2025">2025 (52 semaines)</option>
        <option value="2027">2027 (52 semaines)</option>
      </select>
      <p class="muted">Le profil hebdo est calcul√© au prorata des jours par semaine ISO.</p>
    </div>
  </div>

  <div class="row">
    <button id="runBtn" disabled>G√©n√©rer le HTML mis √† jour</button>
    <span id="runStatus" class="pill">Pr√™t</span>
  </div>

  <div class="card">
    <label>Logs</label>
    <pre id="log"></pre>
  </div>

<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<script>
const $ = (id)=>document.getElementById(id);
const logEl = $("log");
function log(...args){ logEl.textContent += args.join(" ") + "\n"; }
function setStatus(el, txt, cls){
  el.textContent = txt;
  el.className = cls || "muted";
}
function normalizeKey(s){
  return (s||"").toString().trim().toLowerCase().replace(/\s+/g," ");
}
function parseFrNumber(v){
  if(v==null) return 0;
  const s = (""+v).trim().replace(/\s+/g,"").replace(",",".");
  const m = s.match(/-?\d+(\.\d+)?/);
  return m ? parseFloat(m[0]) : 0;
}
function parseVolumeL(fmt){
  if(!fmt) return null;
  let s = (""+fmt).trim().toLowerCase().replace(/\s+/g,"").replace(",",".");
  let m = s.match(/(\d+(?:\.\d+)?)(l|cl|ml)\b/);
  if(!m) return null;
  const val = parseFloat(m[1]);
  const unit = m[2];
  if(unit==="l") return val;
  if(unit==="cl") return val/100;
  if(unit==="ml") return val/1000;
  return null;
}
function daysInMonth(year, month){ // month:1-12
  return new Date(year, month, 0).getDate();
}
function isoWeekNumber(date){
  // https://en.wikipedia.org/wiki/ISO_week_date#Algorithms
  const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
  const dayNum = d.getUTCDay() || 7;
  d.setUTCDate(d.getUTCDate() + 4 - dayNum);
  const yearStart = new Date(Date.UTC(d.getUTCFullYear(),0,1));
  return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
}
function isoWeeksInYear(year){
  // ISO week of Dec 28 defines last ISO week of the year
  return isoWeekNumber(new Date(Date.UTC(year, 11, 28)));
}
function parseCsv(text){
  // CSV simple avec s√©parateur ';' attendu
  // Support minimal des guillemets.
  const lines = text.replace(/^\uFEFF/,'').split(/\r?\n/).filter(l=>l.trim()!=="");
  if(!lines.length) return [];
  const sep = lines[0].includes(";") ? ";" : (lines[0].includes("\t") ? "\t" : ",");
  const rows = [];
  const headers = splitCsvLine(lines[0], sep).map(h=>h.trim());
  for(let i=1;i<lines.length;i++){
    const cols = splitCsvLine(lines[i], sep);
    const row = {};
    headers.forEach((h,idx)=> row[h] = (cols[idx]??"").trim());
    rows.push(row);
  }
  return rows;

  function splitCsvLine(line, sep){
    const out=[]; let cur=""; let inQ=false;
    for(let i=0;i<line.length;i++){
      const ch=line[i];
      if(ch==='"'){ 
        if(inQ && line[i+1]==='"'){ cur+='"'; i++; }
        else inQ=!inQ;
      } else if(ch===sep && !inQ){
        out.push(cur); cur="";
      } else cur+=ch;
    }
    out.push(cur);
    return out;
  }
}


function parseCsvDetailed(text){
  // Retourne: { headers, rows (objets), colsRows (tableau de colonnes) }
  const lines = (text||"").replace(/^\uFEFF/,'').split(/\r?\n/).filter(l=>l.trim()!=="");
  if(!lines.length) return {headers:[], rows:[], colsRows:[]};
  const sep = lines[0].includes(";") ? ";" : (lines[0].includes("\t") ? "\t" : ",");
  const headers = splitCsvLine(lines[0], sep).map(h=>h.trim());
  const rows = [];
  const colsRows = [];
  for(let i=1;i<lines.length;i++){
    const cols = splitCsvLine(lines[i], sep).map(c => (c??"").trim());
    const row = {};
    headers.forEach((h,idx)=> row[h] = (cols[idx]??"").trim());
    rows.push(row);
    colsRows.push(cols);
  }
  return {headers, rows, colsRows};

  function splitCsvLine(line, sep){
    const out=[]; let cur=""; let inQ=false;
    for(let i=0;i<line.length;i++){
      const ch=line[i];
      if(ch==='"'){
        if(inQ && line[i+1]==='"'){ cur+='"'; i++; }
        else inQ=!inQ;
      } else if(ch===sep && !inQ){
        out.push(cur); cur="";
      } else cur+=ch;
    }
    out.push(cur);
    return out;
  }
}

let baseHtmlText = null;
let zipFile = null;

$("baseHtml").addEventListener("change", async (e)=>{
  const f = e.target.files && e.target.files[0];
  if(!f){ setStatus($("baseHtmlStatus"), "Aucun fichier charg√©", "muted"); baseHtmlText=null; updateBtn(); return; }
  setStatus($("baseHtmlStatus"), `S√©lectionn√©: ${f.name} (${Math.round(f.size/1024)} Ko)`, "ok");
  baseHtmlText = await f.text();
  updateBtn();
});

$("zipNeeds").addEventListener("change", async (e)=>{
  const f = e.target.files && e.target.files[0];
  if(!f){ setStatus($("zipStatus"), "Aucun fichier charg√©", "muted"); zipFile=null; updateBtn(); return; }
  setStatus($("zipStatus"), `S√©lectionn√©: ${f.name} (${Math.round(f.size/1024)} Ko)`, "ok");
  zipFile = f;
  updateBtn();
});

function updateBtn(){
  $("runBtn").disabled = !(baseHtmlText && zipFile);
}

function extractEmbeddedData(html){
  const m = html.match(/const\s+EMBEDDED_DATA\s*=\s*({[\s\S]*?});/);
  if(!m) throw new Error("Impossible de trouver const EMBEDDED_DATA = {...}; dans le HTML.");
  const objText = m[1];
  // Parse objet JS (pas JSON strict) ‚Üí Function
  let data;
  try{
    data = (new Function("return ("+objText+");"))();
  }catch(err){
    // fallback: tenter de nettoyer virgules finales
    const cleaned = objText.replace(/,\s*([}\]])/g,"$1");
    data = (new Function("return ("+cleaned+");"))();
  }
  return {data, objText};
}

function downloadText(filename, text){
  const blob = new Blob([text], {type:"text/html;charset=utf-8"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 1500);
}

$("runBtn").addEventListener("click", async ()=>{
  logEl.textContent="";
  $("runStatus").textContent="Traitement‚Ä¶";
  try{
    const year = parseInt($("yearSel").value,10);
    const weeksInYear = isoWeeksInYear(year);
    log("Ann√©e:", year, "| Semaines ISO:", weeksInYear);

    const {data:embedded, objText} = extractEmbeddedData(baseHtmlText);
    if(!embedded || !embedded.products || !embedded.hebdo) throw new Error("EMBEDDED_DATA incomplet (products/hebdo manquant).");
    log("Produits:", embedded.products.length, "| Hebdo:", Object.keys(embedded.hebdo).length);
    // Nettoyage s√©curit√© : certaines versions d'index ont parfois un hebdo sous la cl√© "null"/"undefined"
    if(embedded.hebdo && (embedded.hebdo["null"] || embedded.hebdo["undefined"])){
      delete embedded.hebdo["null"];
      delete embedded.hebdo["undefined"];
      log("üßπ Nettoyage: suppression embedded.hebdo['null'/'undefined']");
    }


    // index produits par libell√©
    const byLabel = new Map();
    const byCode = new Map();
    let maxIdx = 0;
    let maxCode = 0;
    for(const p of embedded.products){
      maxIdx = Math.max(maxIdx, p.idx||0);
      if(p.code_article!=null && !isNaN(p.code_article)) maxCode = Math.max(maxCode, Number(p.code_article));
      if(p.libelle) byLabel.set(normalizeKey(p.libelle), p);
      if(p.code_article!=null) byCode.set(String(p.code_article), p);
    }

    const zip = await JSZip.loadAsync(zipFile);

    function cleanZipNames(){
      return Object.keys(zip.files).filter(n=>!n.startsWith("__MACOSX/") && !n.endsWith("/"));
    }
    const zNames = cleanZipNames();
    const annualName = zNames.find(n=>/besoins\s+annee\.csv$/i.test(n));
    if(!annualName) throw new Error("ZIP: fichier annuel introuvable (attendu: BESOINS ANNEE.csv).");

    const monthNames = {};
    const monthMap = [
      [1, "JANVIER"], [2,"FEVRIER"], [3,"MARS"], [4,"AVRIL"], [5,"MAI"], [6,"JUIN"],
      [7,"JUILLET"], [8,"AOUT"], [9,"SEPTEMBRE"], [10,"OCTOBRE"], [11,"NOVEMBRE"], [12,"DECEMBRE"]
    ];
    for(const [m, lab] of monthMap){
      const re = new RegExp(`besoins\\s+0?${m}\\s+${lab}\\.csv$`, "i");
      const found = zNames.find(n=>re.test(n));
      if(found) monthNames[m]=found;
    }
    const missingMonths = monthMap.filter(([m])=>!monthNames[m]).map(([m,lab])=>lab);
    if(missingMonths.length) log("‚ö†Ô∏è Mois manquants dans le ZIP:", missingMonths.join(", "));

    // Lire annuel
    const annualText = await zip.file(annualName).async("string");
    const annualParsed = parseCsvDetailed(annualText);
    const annualRows = annualParsed.rows;

    // d√©tecter colonnes
    const colVol = (annualRows[0] && Object.keys(annualRows[0]).find(c=>c.toLowerCase().includes("volume"))) || "Volume (L)";
    const colCat = (annualRows[0] && Object.keys(annualRows[0]).find(c=>c.toLowerCase()==="categorie")) || "categorie";
    const colLabel = (annualRows[0] && (Object.keys(annualRows[0]).find(c=>c.toLowerCase()==="libelle_coxx") || Object.keys(annualRows[0]).find(c=>c.toLowerCase()==="composant"))) || "libelle_coxx";
    const colFmt = (annualRows[0] && Object.keys(annualRows[0]).find(c=>c.toLowerCase()==="format")) || "Format";

    const colBrasseur = (annualRows[0] && Object.keys(annualRows[0]).find(c=>c.toLowerCase().includes("brasseur"))) || null;

    function isImpacted(row){
      const cat = normalizeKey(row[colCat]);
      return cat==="alcool" || cat==="soft";
    }
    const annualByLabel = new Map();
    const brasseurByLabel = new Map();
    const metaByLabel = new Map();
    for(let i=0;i<annualRows.length;i++){
      const r = annualRows[i];
      if(!isImpacted(r)) continue;
      const label = (r["libelle_coxx"]||r["Composant"]||r[colLabel]||"").toString().trim();
      if(!label) continue;
      const liters = parseFrNumber(r[colVol]);
      annualByLabel.set(label, liters);

      // BRASSEUR : colonne "Brasseur" si elle existe, sinon colonne J (10e colonne)
      const cols = (annualParsed && annualParsed.colsRows && annualParsed.colsRows[i]) ? annualParsed.colsRows[i] : [];
      const rawBrasseur = (colBrasseur && r[colBrasseur] != null && r[colBrasseur] !== "") ? r[colBrasseur] : (cols[9] ?? "");
      const isBrasseur = normalizeKey(rawBrasseur).startsWith("o"); // "OUI"
      brasseurByLabel.set(normalizeKey(label), isBrasseur);

      if(!metaByLabel.has(label)){
        metaByLabel.set(label, {
          categorie: (r[colCat]||"").toString().trim(),
          format: (r[colFmt]||"").toString().trim(),
          units_per_colis: r["conditionnement_unites_par_colis"],
          cond_unitaire: r["Type de conditionnement unitaire"],
          cond_lot: r["Nom conditionnement vendu en lot"],
          decond: r["D√©condionnement unitaire possible"],
        });
      }
    }
log("Lignes annuel (Soft+Alcool):", annualByLabel.size);

    // Mensuels -> cumul mois + profil jour‚Üísemaine
    const monthlyTotals = new Map(); // label -> sum liters
    const weeklyLiters = new Map();  // label -> Map(week->liters)
    function addWeekly(label, week, liters){
      if(!weeklyLiters.has(label)) weeklyLiters.set(label, new Map());
      const m = weeklyLiters.get(label);
      m.set(week, (m.get(week)||0) + liters);
    }
    for(const [m, name] of Object.entries(monthNames)){
      const month = parseInt(m,10);
      const txt = await zip.file(name).async("string");
      const rows = parseCsv(txt);
      if(!rows.length) continue;
      const colVolM = Object.keys(rows[0]).find(c=>c.toLowerCase().includes("volume")) || colVol;
      const colCatM = Object.keys(rows[0]).find(c=>c.toLowerCase()==="categorie") || colCat;
      for(const r of rows){
        const cat = normalizeKey(r[colCatM]);
        if(!(cat==="alcool" || cat==="soft")) continue;
        const label = (r["libelle_coxx"]||r["Composant"]||"").toString().trim();
        if(!label) continue;
        const litersMonth = parseFrNumber(r[colVolM]);
        monthlyTotals.set(label, (monthlyTotals.get(label)||0) + litersMonth);

        // meta si absent (utile pour ajout)
        if(!metaByLabel.has(label)){
          metaByLabel.set(label, {
            categorie: (r[colCatM]||"").toString().trim(),
            format: (r["Format"]||"").toString().trim(),
            units_per_colis: r["conditionnement_unites_par_colis"],
            cond_unitaire: r["Type de conditionnement unitaire"],
            cond_lot: r["Nom conditionnement vendu en lot"],
            decond: r["D√©condionnement unitaire possible"],
          });
        }

        const dim = daysInMonth(year, month);
        const daily = dim ? litersMonth/dim : 0;
        for(let d=1; d<=dim; d++){
          const dt = new Date(Date.UTC(year, month-1, d));
          const w = isoWeekNumber(dt);
          addWeekly(label, w, daily);
        }
      }
      log("OK mois", month, ":", name);
    }

    // Reconciliation annuel : scale profil mensuel pour matcher l'annuel
    const weeklyScaled = new Map(); // label -> Map(week->liters)
    for(const [label, annLiters] of annualByLabel.entries()){
      const mSum = monthlyTotals.get(label) || 0;
      if(mSum>0){
        const scale = annLiters / mSum;
        const wk = weeklyLiters.get(label) || new Map();
        const out = new Map();
        for(const [w,v] of wk.entries()) out.set(w, v*scale);
        weeklyScaled.set(label, out);
      } else {
        // pas de mensuel ‚Üí uniforme
        const out = new Map();
        const perWeek = annLiters / weeksInYear;
        for(let w=1; w<=weeksInYear; w++) out.set(w, perWeek);
        weeklyScaled.set(label, out);
      }
    }

    
    function applyBrasseurFlag(p, label){
      const flag = brasseurByLabel.get(normalizeKey(label));
      if(flag === true || flag === false){
        p.brasseur = flag;
      }
    }

// helper: ensure product exists (and has code)
    function ensureProduct(label){
      const k = normalizeKey(label);
      let p = byLabel.get(k);

      // Si le produit existe d√©j√† mais n'a pas de code_article (cas rencontr√© dans certains index),
      // on lui en attribue un pour √©viter d'√©crire dans embedded.hebdo["null"/"undefined"].
      if(p){
        if(p.idx==null){ maxIdx += 1; p.idx = maxIdx; }
        if(p.code_article==null || p.code_article==="" || isNaN(Number(p.code_article))){
          maxCode += 1;
          p.code_article = maxCode;
        } else {
          // s'assure que maxCode reste au-dessus
          maxCode = Math.max(maxCode, Number(p.code_article));
        }
        byCode.set(String(p.code_article), p);
        applyBrasseurFlag(p, label);
        return p;
      }

      const meta = metaByLabel.get(label) || {};
      maxIdx += 1; maxCode += 1;
      p = {
        idx: maxIdx,
        libelle: label,
        categorie: meta.categorie || "Soft",
        format_lib: meta.format || "",
        units_per_colis: parseInt((meta.units_per_colis||"1").toString().match(/\d+/)?.[0]||"1",10),
        code_article: maxCode,
        cond_unitaire_lib: meta.cond_unitaire || "",
        cond_lot_lib: meta.cond_lot || "",
        decond_possible: meta.decond || "Oui",
        prix_vente_ttc: null, tva_pct: null, prix_vente_ht: null, prix_achat_ht_unite: null, marge_euro: null, marge_pct: null
      };
      applyBrasseurFlag(p, label);
      embedded.products.push(p);
      byLabel.set(k,p);
      byCode.set(String(p.code_article),p);
      return p;
    }

    // Mise √† jour hebdo (unit√©s/semaine) uniquement Soft + Alcool
    let updatedCount = 0;
    let skippedNoFormat = 0;
    for(const [label, wkLiters] of weeklyScaled.entries()){
      const p = ensureProduct(label);
      const cat = normalizeKey(p.categorie);
      if(!(cat==="alcool" || cat==="soft")) continue;

      const volUnit = parseVolumeL(p.format_lib) || parseVolumeL((metaByLabel.get(label)||{}).format);
      if(!volUnit || !(volUnit>0)){
        skippedNoFormat++;
        continue;
      }
      const out = {};
      for(let w=1; w<=weeksInYear; w++){
        const liters = wkLiters.get(w) || 0;
        out[String(w)] = liters / volUnit; // unit√©s
      }
      embedded.hebdo[String(p.code_article)] = out;
      updatedCount++;
    }

    log("Maj hebdo:", updatedCount, "| Ignor√©s (format invalide):", skippedNoFormat);

    // Remplacer EMBEDDED_DATA dans le HTML par un JSON propre (valide JS)
    const newEmbeddedText = JSON.stringify(embedded);
    const newHtml0 = baseHtmlText.replace(objText, newEmbeddedText);

    // Pr√©-cocher BRASSEUR (si p.brasseur est pr√©sent dans EMBEDDED_DATA.products)
    const newHtml = newHtml0.replace(/brasseur\s*:\s*false\s*,/g, "brasseur: !!p.brasseur,");

    // Par d√©faut, d√©cocher "Inclure" pour les cat√©gories Vaisselle & Autres
    let newHtml2 = newHtml;
    // 1) Defaults d'√©tat (init) quand on construit state[p.idx]
    newHtml2 = newHtml2.replace(/(state\[p\.idx\]\s*=\s*\{[\s\S]*?)include\s*:\s*true\s*,/g,
      "$1include: (p.categorie !== \"Vaisselle\" && p.categorie !== \"Autres\"),");

    // 2) Init de secours √† l'import (state[pid])
    newHtml2 = newHtml2.replace(/state\[pid\]\s*=\s*\{\s*countMode\s*:\s*\"colis\"\s*,\s*stockCount\s*:\s*0\s*,\s*orderUnitsOverride\s*:\s*null\s*,\s*orderLotsOverride\s*:\s*null\s*,\s*include\s*:\s*true\s*,\s*brasseur\s*:\s*false\s*\}\s*;/,
`const _p0 = PRODUCTS.find(x => x.idx === pid);
          const _cat0 = _p0 ? String(_p0.categorie || "") : "";
          const _defaultInclude0 = !(_cat0 === "Vaisselle" || _cat0 === "Autres");
          state[pid] = { countMode: "colis", stockCount: 0, orderUnitsOverride: null, orderLotsOverride: null, include: _defaultInclude0, brasseur: false };`);

    // 3) Affichage checkbox "Inclure ?" (√©vite un d√©faut = true)
    newHtml2 = newHtml2.replace(/cbInclure\.checked\s*=\s*[^;]*;\s*\/\/\s*d√©faut\s*=\s*true/g,
      'cbInclure.checked = (st.include !== undefined && st.include !== null) ? !!st.include : !(p.categorie === "Vaisselle" || p.categorie === "Autres"); // d√©faut: d√©coch√© pour Vaisselle/Autres');

    const newHtmlFinal = newHtml2;


    const outName = `STOCK_COXX_MAJ_BESOINS_${year}.html`;
    downloadText(outName, newHtmlFinal);
    $("runStatus").textContent="Termin√© ‚úÖ";
  }catch(e){
    console.error(e);
    log("‚ùå Erreur:", e && e.message ? e.message : e);
    $("runStatus").textContent="Erreur ‚ùå";
  }
});
</script>
</body>
</html>
